## Фича: дедупликация одинаковых уязвимостей из разных отчётов

---

### 1. Контекст и гипотеза
- **Гипотеза:** AppSec инженеры тратят много времени на повторяющиеся findings, потому что nightly/pipeline сканы создают множество копий одной и той же уязвимости. Если сворачивать дубликаты в одну карточку, triage ускорится и снизится шум.
- **Целевая роль:** AppSec инженер / triage lead.
- **Сигналы / данные:** В пользовательских интервью (итог итерации 1) замечено, что при загрузке нескольких SARIF подряд одни и те же `ruleId + location` повторяются до 5 раз; нет способа понять, что это одна и та же проблема.

### 2. Что делаем (scope)
- **Основной сценарий:** Пользователь загружает несколько SARIF отчётов; viewer автоматически группирует одинаковые уязвимости и показывает счётчик «в скольких отчётах найдено».
- **Границы:** Не делаем автоматическое закрытие findings, не синхронизируем suppressions обратно в репозиторий. Не затрагиваем отчёты, в которых нет `partialFingerprints`.
- **Артефакты:** 
  - Обновление `src/lib/normalize-sarif.ts` и `parse-sarif` для расчёта `finding_fingerprint`.
  - Новое поле в Supabase `sarif_reports.normalized.findings[].dedupeKey`.
  - UI-группа «Сгруппировано X отчётов» + фильтр «показывать дубликаты отдельно/свернуть».

### 3. Зачем делаем (value)
- **Ожидаемая польза:** Сократить время triage на 20% (поfollow-up интервью); уменьшить количество ручных пометок «duplicate»; повысить доверие к viewer для продвинутых команд.
- **Принципы, на которые опираемся:** `docs/development-principles.md` (Security-by-default - отображаем метаданные источника), `docs/architecture-principles.md` (Client-light: вычисляем ключ на backend), `docs/ux-principles.md` (Слои информации, простая визуализация дубликатов).
- **Риски / trade-offs:** Возможные ложные срабатывания (слишком агрессивная дедупликация), увеличение времени нормализации за счёт хеширования.

### 4. Как делаем (implementation notes)
- **Технический план:**
  1. В нормализаторе формируем `dedupeKey` как SHA-256 от конкатенации: `ruleId`, `level`, `message.text`, `primaryLocation.uri`, `primaryLocation.region.startLine`, `partialFingerprints` (если есть). Приоритет — использовать `partialFingerprints.primaryLocationFingerprint` и `partialFingerprints.` указанные в SARIF.
  2. В Netlify Function записываем `dedupeKey` вместе с finding, а также вычисляем `dedupeGroupId = hash(dedupeKey)` и агрегируем в Supabase view `finding_groups` (группировка по `dedupeKey`, count(report_id)).
  3. Во фронтенде загружаем агрегированные данные: отображаем «Найдено в N отчётах» и список отчётов в раскрытии.
  4. Добавляем фильтр «Показывать только уникальные» (скрывает повторные записи внутри группы).
- **Интеграции и зависимости:** Изменение схемы Supabase (`normalized` JSON); возможно, добавление materialized view `deduped_findings` с индексом по `dedupeKey`. Необходим апдейт типов `frontend/src/types/sarif.ts`.
- **Тесты и валидация:** Unit-тесты для нормализатора (новые фикстуры SARIF с одинаковыми/разными findings); e2e сценарий сверки с UI; UX review на отображение групп. После релиза — наблюдение метрики «среднее кол-во findings в triage после дедупликации».

### 5. Проверка готовности
- [ ] Код ревью + тесты пройдены
- [ ] Документация обновлена (`README`/`docs`)
- [ ] Телеметрия/логи добавлены (логируем dedupeKey generation + агрегации)
- [ ] UX соответствует гайдам (ссылка на макеты/PR)

---

> Источники: `docs/development-principles.md`, `docs/architecture-principles.md`, `docs/documentation-principles.md`, `docs/ux-principles.md`.

